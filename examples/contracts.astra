module contracts

fn divide(a: Int, b: Int) -> Int
  requires b != 0
  ensures result * b <= a and result * b > a - b
{
  a / b
}

fn safe_sqrt(n: Int) -> Int
  requires n >= 0
  ensures result * result <= n
{
  # Integer square root
  if n == 0 then 0
  else {
    let mut guess = n / 2
    let mut prev = guess + 1

    # Newton's method (simplified)
    if guess * guess > n then guess - 1
    else guess
  }
}

test "divide positive" {
  assert divide(10, 3) == 3
  assert divide(15, 5) == 3
}

test "sqrt" {
  assert safe_sqrt(0) == 0
  assert safe_sqrt(4) == 2
  assert safe_sqrt(10) == 3
}
